---
title: Data Structires - Stacks
date: 2020-12-22
tags: ['data structures', 'stacks']
---

Stacks are a linked data structure that uses the last-in first-out principle or LIFO. It is the opposite of a queue where the first item put on the stack is operated on. Like linked lists and queues, a stack’s insert and delete operation is O(1) because we are only performing these operations on the last item in the stack. Likewise, access and search at both O(n) as these are dependent on the size of the stack. The two primary methods of a stack are push and pop. 

Since JS has native pop and push methods, I decided to implement this DS twice. One uses and array and the other uses an object. In all reality, I would never need to implement a stack in JS, but I think it's good practice to understand this DS.

## Diagram of stack
		A

		↓

		B

		↓

		C

## Use cases
Stacks are used for a variety of algorithms such as breadth-first search for backtracking. 


## Time Complexity
operation \| |\| average |\| worst
--- | --- | ---
peek    	| O(1) | O(1) 
push  		| O(1) | O(1) 
pop		| O(1) | O(1)

## Implementation with Object
```
class Node {
	constructor() {
		this.data = [];
	}
}

class Stack {
	constructor(head = null) {
		this.head = head;
	}

	push(value) {
		if(!this.head) {
			this.head = new Node();
			this.head.data.push(value);
		} else {
			this.head.data.push(value);
		}
	}

	pop() {
		if(!this.head) {
			return 'there is no stack to delete';
		} else {
			this.head.data.pop();
		}
	}

	peek() {
		if (!this.head) {
			return 'there is no stack';
		} else {
			return this.head.data[0];
		}
	}
}

let stack = new Stack();
stack.push('first');
stack.push('second');
stack.push('third');
stack.pop();
console.log(stack.peek());

```


## Implementation with Object
```
class NodeObject {
	constructor() {
		this.data = {};
	}
}

class StackObject {
	constructor() {
		this.head = null;
		this.count = 0;
	}

	push(value) {
		if(!this.head) {
			this.head = new NodeObject();
			this.head.data[this.count] = value;
			this.count++;
			return;
		}

		this.head.data[this.count] = value;
		this.count++;	
	}

	pop() {
		if(!this.head) return 'there is no stack';
		
		this.count--;
		delete this.head.data[this.count];
	}

	peek() {
		if(!this.head) return 'there is no stack';

		return this.head.data[this.count - 1];
	}
}


let stackObject = new StackObject();
stackObject.push('first');
stackObject.push('second');
stackObject.push('third');
stackObject.pop();

console.log(stackObject.peek());

```



