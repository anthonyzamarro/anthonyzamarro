---
title: Data Structures - Binary Search Trees
date: 2020-11-30
tags: ['data structures', 'trees', 'binary search trees']
---


## Overview

Binary search trees are a linked data structure that consist of having a root node along with one or two child nodes. They are usually implemented using recursion and this can be powerful because using recursion can give us runtimes of O(log n)
 if we have a balanced tree. 

Some features of binary search trees:
- data in a tree is called a node
- a tree always has a root node and at most two child nodes
- children of nodes are ordered from least to greatest as in a node's left child will be less than its parent node and a node's right child will be greater than its parent node

## Applications

A common place where we see a tree data structure is the file sytem on your computer. This gives us a good visual about what a tree looks like.
Some common applications of BSTs (or trees in general) include:
- the DOM
- JSON objects
- File Systems 

## Runtimes

As stated, if we have a balanced binary search tree then our runtimes are O(log n) in the average case and O(n) in the worst case.

operation \| |\| average |\| worst
--- | --- | ---
search  	| O(log n) |	O(n) 
insert          | O(log n) |    O(n) 
traverse	| O(log n) |	O(n)
delete		| O(log n) |	O(n)

## Implementation
```
let Node = (data) => {
	this.data = data;
	this.left = null;
	this.right = null
}

let BinarySearchTree = () => {
	this.root = null;


	this.insert = (value) => {
	let root = this.root;
	    if(this.root == null)  {
		this.root = new Node(value);
	    } else {
		    const insertNode = (node) => {  
			    if(value < node.data) {      
				    if(node.left == null) {
					node.left = new Node(value);
					return;
				    } else {
					return	insertNode(node.left);
				    }
			    } else if (value > node.data) {
				    if (node.right == null) {
					node.right = new Node(value);
				    } else if (node.right !== null){
					return	insertNode(node.right);
				    }
			    } else {
				return null;
			    }
		    }
		return insertNode(root);

	    } 
    }
	
	
	
	
	
	
	
	
	
	
	
	this.delete = () => {

	}

	this.search = (value) => {
		let root = this.tree;
		if(!node || root.data === value) return ;
		
		if(value < root.value){
			return search(root.left);
		}
		if(value > root.value) {
			return search(root.right);
		}
	}

	// in-order traversal is best as it always results in a sorted list of nodes
	this.traverse = (node) => {
		if (node === null) return;

		let left = this.traverse(node.left);
		console.log(left);
		let right = this.traverse(node.right);
		console.log(right);
	}

	this.isBinarySearch = () => {

	}

	this.isBalanced = () => {

	}
	
	this.minHeight = () => {

	}

	this.maxHeight = () => {

	}
}
```


